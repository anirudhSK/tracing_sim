/* This file contains functions relating to creating and comparing trace and target (user-given) graphs */

use petgraph::algo::{dijkstra, toposort};
use petgraph::graph::{Graph, NodeIndex};
use std::collections::HashMap;

/* This function creates a petgraph graph representing the query given by the user.
 * For example, if the cql query were MATCH n -> m, e WHERE ... the input to this function
 * would be vertices = [n, m], edges = [(n,m)].
 *
 * Arguments:
 * @vertices:  the vertices of the graph to construct
 * @edges:  the edges of the graph to construct
 *
 * Return Value:
 * @graph: the constructed graph reprsenting the inputs
 */

pub fn generate_target_graph(
    vertices: Vec<String>,
    edges: Vec<(String, String)>,
    ids_to_properties: HashMap<String, HashMap<String, String>>,
) -> Graph<(String, HashMap<String, String>), String> {
    let mut graph = Graph::new();

    // In order to make edges, we have to know the handles of the nodes, and you
    // get the handles of the nodes by adding them to the graph

    let mut nodes_to_node_handles: HashMap<String, NodeIndex> = HashMap::new();
    for node in vertices {
        assert!(ids_to_properties.contains_key(&node), "{0} is a node that wasn't in ids_to_properties\n", node);
        nodes_to_node_handles.insert(node.clone(), graph.add_node((node.clone(), ids_to_properties[&node].clone())));
    }

    // Make edges with handles instead of the vertex names
    let mut edge_handles = Vec::new();
    for edge in edges {
        let node0 = nodes_to_node_handles[&edge.0];
        let node1 = nodes_to_node_handles[&edge.1];
        let new_edge = (node0, node1);
        edge_handles.push(new_edge);
    }
    graph.extend_with_edges(edge_handles);

    graph
}

/*  This function creates a petgraph graph representing a single trace.
 *  The trace is represented in paths_header as a string where the first node is
 *  the root.  Thus "0 1 2" is a graph that looks like 0 -> 1 -> 2 with 0 as root.
 *
 *  Arguments:
 *  @paths_header:  the string version of the trace, generated by the tracing simulator
 *  @properties_header: the string containing the properties of the nodes in the path
 *  It is of the form node_name.property == "xyz",
 *  For example, a.response.total_size==4, b.response.total_size==5,
 *
 *  Return Value:
 *  @graph:  A petgraph graph representation of the same trace
 */
pub fn generate_trace_graph_from_headers(
    paths_header: String,
    properties_header: String,
) -> Graph<(String, HashMap<String, String>), String> {
    let mut graph = Graph::new();
    let mut nodes_iterator = paths_header.split_whitespace();
    let mut node_str_to_node_handle = HashMap::new();
    let first_node = nodes_iterator.next();
    if first_node.is_none() {
        return graph; // clearly we don't have anything, so return an empty graph
    }
    let first_node_str = first_node.unwrap();
    let mut first_node_hashmap = HashMap::new();
    first_node_hashmap.insert(
        "node.metadata.WORKLOAD_NAME".to_string(),
        first_node_str.to_string(),
    );
    node_str_to_node_handle.insert(
        first_node_str.to_string(),
        graph.add_node((first_node_str.to_string(), first_node_hashmap)),
    );
    let mut prev_node_handle = node_str_to_node_handle[first_node_str];
    for node_str in nodes_iterator {
        // 1. Is this node already in the graph?  If so, ignore it and move "up" the tree
        if !node_str_to_node_handle.contains_key(&node_str.to_string()) {
            let mut new_node_hashmap = HashMap::new();
            new_node_hashmap.insert(
                "node.metadata.WORKLOAD_NAME".to_string(),
                node_str.to_string(),
            );
            let new_node_handle = graph.add_node((node_str.to_string(), new_node_hashmap));
            node_str_to_node_handle.insert(node_str.to_string(), new_node_handle);
            graph.add_edge(prev_node_handle, new_node_handle, "".to_string());
            prev_node_handle = new_node_handle;
        } else {
            prev_node_handle = node_str_to_node_handle[node_str];
        }
    }

    // now insert properties:
    // do we have any?
    let comma_index = properties_header.find(",");
    if !comma_index.is_none() {
        let properties_iterator = properties_header.split(",");
        for statement in properties_iterator {
            if !statement.find("==").is_none() {
                let mut values_iterator = statement.split("==");
                let property_with_node = values_iterator.next().unwrap().clone().to_string();
                let mut period_iterator = property_with_node.split(".");
                let node = period_iterator.next().unwrap();
                let mut property = String::new();
                for quality in period_iterator {
                    property.push_str(&quality);
                    property.push_str(".");
                }
                let _ = property.pop();  // get rid of trailing period
                let node_weight: &mut (String, HashMap<String, String>) = graph.node_weight_mut(node_str_to_node_handle[node]).unwrap();
                node_weight.1.insert(property, values_iterator.next().unwrap().to_string());
            }
        }
    }
    graph
}

pub fn get_node_with_id(graph: &Graph<(String, HashMap<String, String>), String>, node_name: String) -> Option<NodeIndex> {
    for index in graph.node_indices() {
        if &graph.node_weight(index).unwrap().0 == &node_name {
            return Some(index);
        }
    }
    None
}

pub fn get_tree_height(
    graph: &Graph<(String, HashMap<String, String>), String>,
    root: Option<NodeIndex>,
) -> u32 {
    let starting_point;
    if !root.is_none() {
        starting_point = root.unwrap()
    } else {
        // The root of the tree by definition has no incoming edges
        let sorted = toposort(graph, None).unwrap();
        starting_point = sorted[0];
    }
    let node_map = dijkstra(graph, starting_point, None, |_| 1);
    let mut max = 0;
    for key in node_map.keys() {
        if node_map[key] > max {
            max = node_map[key];
        }
    }
    return max;
}

pub fn get_out_degree(
    graph: &Graph<(String, HashMap<String, String>), String>,
    root: Option<NodeIndex>,
) -> u32 {
    let starting_point;
    if !root.is_none() {
        starting_point = root.unwrap()
    } else {
        // The root of the tree by definition has no incoming edges
        let sorted = toposort(graph, None).unwrap();
        starting_point = sorted[0];
    }
    return graph.neighbors(starting_point).count() as u32;
}

#[cfg(test)]
mod tests {
    use super::*;

    fn make_small_trace_graph() -> Graph<(String, HashMap<String, String>), String> {
        let graph_string = String::from("0 1 2");
        let graph = generate_trace_graph_from_headers(graph_string, String::new());
        graph
    }

    fn make_small_target_graph() -> Graph<(String, HashMap<String, String>), String> {
        let a = String::from("a");
        let b = String::from("b");
        let c = String::from("c");
        let vertices = vec![a.clone(), b.clone(), c.clone()];
        let edges = vec![(a.clone(), b.clone()), (b.clone(), c.clone())];
        let mut ids_to_properties = HashMap::new();

        let mut a_hashmap = HashMap::new();
        a_hashmap.insert("node.metadata.WORKLOAD_NAME".to_string(), "a".to_string());
        ids_to_properties.insert("a".to_string(), a_hashmap);

        let mut b_hashmap = HashMap::new();
        b_hashmap.insert("node.metadata.WORKLOAD_NAME".to_string(), "b".to_string());
        ids_to_properties.insert("b".to_string(), b_hashmap);

        let mut c_hashmap = HashMap::new();
        c_hashmap.insert("node.metadata.WORKLOAD_NAME".to_string(), "c".to_string());
        ids_to_properties.insert("c".to_string(), c_hashmap);

        assert!(ids_to_properties.keys().len()==3);
        assert!(ids_to_properties.contains_key(&"a".to_string()));
        assert!(ids_to_properties.contains_key(&"b".to_string()));
        assert!(ids_to_properties.contains_key(&"c".to_string()));
        for vertex in &vertices {
            assert!(ids_to_properties.contains_key(vertex));
        }
        let graph = generate_target_graph(vertices, edges, ids_to_properties);
        graph
    }

    #[test]
    fn test_generate_trace_graph_from_headers_non_branching_graph() {
        let graph = make_small_trace_graph();
        assert_eq!(graph.node_count(), 3);
        assert_eq!(graph.edge_count(), 2);
    }

    #[test]
    fn test_generate_target_graph() {
        let graph = make_small_target_graph();
        assert_eq!(graph.node_count(), 3);
        assert_eq!(graph.edge_count(), 2);
    }

    #[test]
    fn test_correctly_parse_branching_graphs() {
        let graph = generate_trace_graph_from_headers("0 1 3 1 2".to_string(), String::new());
        assert!(graph.node_count() == 4);
        for node in graph.node_indices() {
            if graph.node_weight(node).unwrap().1["node.metadata.WORKLOAD_NAME"] == "0" {
                assert!(graph.neighbors(node).count() == 1);
            }
            if graph.node_weight(node).unwrap().1["node.metadata.WORKLOAD_NAME"] == "1" {
                assert!(graph.neighbors(node).count() == 2);
            }
        }
    }

    #[test]
    fn test_generate_trace_graph_from_headers_on_empty_string() {
        let graph = generate_trace_graph_from_headers(String::new(), String::new());
        assert!(graph.node_count() == 0);
    }

    #[test]
    fn test_get_tree_height() {
        let graph = generate_trace_graph_from_headers("0 1 3 1 2".to_string(), String::new());
        assert!(get_tree_height(&graph, None) == 2);
    }

    #[test]
    fn test_get_out_degree() {
        let straight_graph = generate_trace_graph_from_headers("0 1 2 3 4 5 6".to_string(), String::new());
        assert!(get_out_degree(&straight_graph, None) == 1);
    }


    #[test]
    fn test_get_node_with_id() {
        let graph = generate_trace_graph_from_headers(" 0 1 2 3 ".to_string(), String::new());
        let ret = get_node_with_id(&graph, "0".to_string());
        assert!(!ret.is_none());
    }

    #[test]
    fn test_parsing_of_properties_in_trace_graph_creation() {
        let graph = generate_trace_graph_from_headers(" 0 1 2 3 ".to_string(), "0.property==thing,".to_string());
        let ret = get_node_with_id(&graph, "0".to_string()).unwrap();
        assert!(graph.node_weight(ret).unwrap().1[&"property".to_string()] == "thing");
    }
}
